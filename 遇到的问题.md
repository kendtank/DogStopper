# ESP32-S3 + PlatformIO 开发笔记

## 一、基本信息
- 系统：ubuntu22.04
- 芯片型号：ESP32-S3
- 开发板：ESP32-S3-DevKitC-1-N16R8
- IDE/工具：VSCode
- 框架：Arduino

## 二、遇到的问题
**1. 串口打印无输出**
   - 问题描述：platformio连接开发板, 调用serial.print()打印数据，串口监测不到数据
   - 解决方法：在platformio.ini中添加如下代码：
   ```
   upload_speed = 921600
   ```
   并且上传镜像之后打开串口监控的控制台，再按下reset按键，就会显示打印的数据


**2. 板子无法启用PSRAM内存**
   - 问题描述：开发板选择[Espressif ESP32-S3-DevKitC-1-N8 (8 MB QD, No PSRAM)]之后无法启用PSRAM内存
   - 解决方法：由于板子是N16R8型号，platformio板子中没有这个型号，只能使用[Espressif ESP32-S3-DevKitC-1-N8 (8 MB QD, No PSRAM)]， 然后再platformio.ini中添加如下配置：
   ```
   platform = espressif32
   board    = esp32-s3-devkitc-1    ; 选通用 S3 DevKitC
   framework= arduino
   ; --- Flash & PSRAM 接口配置 ---
   board_build.flash_mode    = qio       ;  指定FLASH和PSRAM的运行模式 Flash 用 QIO
   board_build.arduino.memory_type = qio_opi  ; Flash QIO + PSRAM Octal
   board_build.psram_type    = opi       ; PSRAM 用 Octal mode
   ; --- 大小定义 ---
   board_upload.flash_size   = 16MB
   board_upload.maximum_size = 16777216  ; 一定要和 16MB 对齐
   board_build.partitions    = default_16MB.csv  ; 用 16MB 分区表
   ; 指定为16MB的FLASH分区表
   board_build.arduino.partitions = default_16MB.csv
   ; --- 启用 PSRAM 宏 ---
   board_build.extra_flags   = -DBOARD_HAS_PSRAM
   ```
  配置完成之后，重新拔插板子，再编译测试是否可以申请PSRAM的代码进行测试。
  

**3. platformio无法使用TensorflowLite for MicroController插件**
   - 问题描述：platformio无法使用TFLM插件
   - 解决方法：添加官方的tflm git仓库运行测试，会提示缺少很多的第三方库，一般是flatbuffers以及别的库，手动去下载很麻烦，但是Arduino IDE是有官方的ESP32_TFLM插件的全称[TensorFlowLite_ESP32], 所以可以尝试使用Arduino IDE下载插件，再把源码拷贝到lib目录中，引入如下一行代码：
   ```
   #include <TensorFlowLite_ESP32.h>
   ```
   添加完之后，就可以使用TFLM插件了
   注意：正常的tf-lite的代码还是需要自己引入的, 如果需要使用硬件级别的加速tflm, 需要使用esp官方的TFLM插件，我目前使用的库中没有使用硬件加速，只能使用软件加速， 因为速度已经满足了。

**4. 快速傅里叶变换(FFT)计算运行速度很慢**
   - 问题描述：手写FFT算法，因为需要大量的复数运算，导致运行速度很慢(测试10s 16k的音频需要70s左右)
   - 解决方法：采用ESP的dsp库进行加速，采用dsps_fft2r进行快速傅里叶变换，速度大大提升， 可以详细查看[ESP32-DSP-Library](https://github.com/espressif/esp-dsp)。

**5. 使用ESP的dsp库加速FFT计算, 遇到空指针错误**
   - 问题描述：使用dsps_fft2r_fc32(fft_buf, N_FFT);进行快速傅里叶变换，但是运行过程中会报空指针错误
   - 解决方法：在使用dsps_fft2r_fc32()之前，必须调用dsps_fft2r_init_fc32(NULL, CONFIG_DSP_MAX_FFT_SIZE);进行初始化，否则在申请内存空间时会报空指针错误

**6. 使用unity进行单元测试遇到的问题**
   - 问题描述：使用unity进行单元测试，遇到了很多的问题
   - 解决方法：platformio创建项目会生成一个test 目录，里面就是为了存放了unity的测试代码，在test目录下创建一个测试的cpp文件，按照main.cpp的格式进行编码，运行项目会报错，找不到自己写的主功能代码，因为头文件默认是指定的include目录，但是unity测试默认不编译src目录下的代码。所以需要在platformio.ini中指定：
   ```
   test_framework = unity
   test_build_project_src = yes  
   ```
   unity测试默认不编译src目录下的代码，启用此选项以编译src目录下的代码， 但是src中有main.cpp, 需要屏幕其中的setup和loop函数, 这样才能进行烧录测试。否则会报错找到两个setup和loop函数。

**7. 使用platformio进行debug遇到问题**
   - 问题描述：使用platformio进行debug报异常
   - 解决方法：配置platformio.ini文件，添加如下代码：
   ```
   debug_tool = esp-builtin
   debug_init_break = tbreak setup
   build_type = debug
   ```
   添加了esp-builtin调试工具，添加了debug_init_break，指定了在setup函数开始时断点，添加了build_type = debug，指定了debug模式，最后打开终端执行：
   ```
   curl -fsSL https://raw.githubusercontent.com/platformio/platformio-core/develop/platformio/assets/system/99-platformio-udev.rules | sudo tee /etc/udev/rules.d/99-platformio-udev.rules
   sudo service udev restart
   ```
   重新拔插板子，这样platformio就会在setup函数开始时断点，然后进行debug。使用vsode进行正常的板子层级别的debug功能

**8. c语言实现的log-mel算法的提取和python的实现保持算法功能上的一致性问题(难点)**

- 问题描述：c语言实现的log-mel算法的提取和python的实现保持算法功能一致性的问题，导致提取的特征值不一致，影响后续的模型推理结果。
- 解决方法：
  1. 确定算法的实现逻辑，按照算法步骤，分布debug操作。python实现和mcu中的c语言实现，找到不一致的地方，进行修改。确保python算法和mcu算法功能一致。
  2. 确定输入一致，随机生成500Hz正弦波测试信号， 截断为200ms, 3200点采样点，进行测试，数组输入一致(pass)
  3. 生成汉宁窗函数，确定汉宁窗权值一致， 误差不超过：1e-6f(pass)
  4. 对音频进行分帧，对每一帧进行汉宁窗加权计算(对每个窗口内的采样点进行汉宁系数的加权)，确定python端和c端计算结果一致，误差不超过：1e-6f(pass)
  5. 采用ESP32的dsp库进行快速傅里叶变换，确定python端和c端功率谱总能量误差不超过0.1%(pass)
  6. 如下步骤：
  ``` python
   # Step 1. FFT（正向不缩放） np.fft.rfft() 只返回正频率部分（包含直流 DC 和 Nyquist 分量），而完整能量包括了正频率和负频率两个对称部分。
   fft = np.fft.rfft(frames_win, axis=0) # np.fft.rfft(frames_win, axis=0) → 对每一列（每帧）做 RFFT， 因为numpy是按列优先存储的， abs(...)**2 → 得到功率谱
   # Step 2. 功率谱，除以 NFFT 以实现能量守恒
   powspec = np.abs(fft)**2 / n_fft
   # 注意：乘以 2 来补偿负频率的能量
   powspec[1:-1, :] *= 2
   powspec = powspec.astype(np.float32)
   #  Step 3. 导出为一维平铺数组
   powspec_all = powspec.T.flatten()  # shape = (num_frames*(FRAME_SIZE//2+1),)
   save_to_header(powspec_all, "powspec_all", "out/powspec_all.h")
   # Step 4. 打印验证
   print("powspec shape:", powspec.shape)
   print("first frame energy sum:", np.sum(powspec[:, 0]))
   print("mean total energy:", np.mean(np.sum(powspec, axis=0)))
   total_energy_input = np.sum(frames_win**2)
   total_energy_spec = np.sum(powspec)
   print("Energy ratio (spec/input):", total_energy_spec / total_energy_input)

   # 运行结果
   """
   波形数组读取成功: shape=(3200,), dtype=float32
   └── 导出 hann_window: shape=(400,), path=out/hann_window.h
   └── 导出 frame0_windowed: shape=(400,), path=out/frame0_windowed.h
   └── 导出 frame_windowed_all: shape=(18, 400), path=out/frame_windowed_all.h
   └── 导出 powspec_all: shape=(3618,), path=out/powspec_all.h
   powspec shape: (201, 18)
   first frame energy sum: 6.750006
   mean total energy: 6.750006
   Energy ratio (spec/input): 0.99999994
   """
  ```

  ``` CPP
   /**
    * @brief 计算输入帧的功率谱（已包含Hann窗能量补偿）
   * 
   * @param frame_in   输入帧（长度 NFFT） HANN窗加权分帧后的数据
   * @param powspec_out 输出功率谱（长度 NFFT/2+1）
   * @param NFFT       FFT点数
   * 
   * @return float     总功率（能量）
   */

   float compute_power_spectrum(const float *frame_in, float *powspec_out, int NFFT)
   {
      const int NBIN = NFFT / 2 + 1;
      float *fft_buf = (float *)malloc(sizeof(float) * 2 * NFFT);
      if (!fft_buf) {
         printf("malloc FFT buffer failed\n");
         return 0.0f;
      }

      // === 1. 准备FFT输入 ===
      for (int i = 0; i < NFFT; i++) {
         fft_buf[2 * i]     = frame_in[i];
         fft_buf[2 * i + 1] = 0.0f;
      }

      // === 2. 执行FFT ===
      dsps_fft2r_fc32(fft_buf, NFFT);
      // 注意Python rfft 输出 已经按 0~Nyquist 排列，c需要额外 bit-reverse。
      dsps_bit_rev_fc32(fft_buf, NFFT);

      // === 3. 计算功率谱 ===
      float total_power = 0.0f;
      float scale = (1.0f / NFFT) * HANN_ENERGY_COMP; //Python 的 np.hanning + rfft 得出的总能量是 未经补偿的实际功率。c端如果加了 HANN_ENERGY_COMP = 1/0.638，总能量就会放大回原值。

      for (int i = 0; i < NBIN; i++) {
         float re = fft_buf[2 * i];
         float im = fft_buf[2 * i + 1];
         // 对齐 FFT 缩放系数和非 DC/Nyquist bin 乘 2
         float val = (re * re + im * im) * scale;
         if (i != 0 && i != NFFT / 2) val *= 2.0f;
         powspec_out[i] = val;
         total_power += val;
      }

      free(fft_buf);
      return total_power;
   }

  ```
  注意：每个 bin 不必完全一致, 原因是 Python 和 C 端 FFT 实现不同（精度、算法、顺序、缩放等），只要总能量接近，后续处理（Mel 滤波器、log-Mel、MFCC）就不会出问题。
  总能量对齐: 确保窗函数能量补偿（HANN_ENERGY_COMP）或整体归一化，使 C 端总能量 ≈ Python 总能量, 这样经过 Mel 滤波器和 log-Mel 后，特征值差异很小，可以用于训练或推理, 换句话说，不用纠结每个 bin 的微小差异，只要最终 MFCC / log-Mel 特征和 Python 对齐即可。

**9. mfcc特征值和python的实现保持一致性的问题**



**10. 自定义实现的mfcc特征值的归一化问题(重点)**

**11. tensorflow-lite模型的设计与训练策略以及导出cc数组的步骤和注意事项**

**12. tensorflow-lite模型的量化以及部署mcu中保证推理结果误差不超过5%的注意事项和步骤(难点)**

**13. 产品的架构设计和模块间的解耦设计(重点)**

**14. VAD初筛算法的实现和音频流滑窗的架构设计(难点)**

**15. 算法误判率减少的方法和优化(重点)**


**16. 事件延时的处理(产生事件到检测结果的秒级内响应)**


**17. 部署在mcu后的整体优化点**
1. 事件窗步长延长为100ms，覆盖率为50%， 延迟减少10倍
2. 音频预处理模块的二次优化点：
   2.1 hann窗改为dsp库实现


