# 端侧声纹自学习系统设计说明（README）

## 1. 项目背景

本项目面向 **MCU / IoT 端侧设备** 的声纹识别场景，典型应用为：

* 单只狗的狗吠识别与验证
* 无人工标注、无云端参与的自动声纹建模
* 在算力、存储受限条件下实现**稳定、可冻结、不漂移**的声纹模板

核心目标：

> 在端侧，通过事件级 embedding 的无监督自学习，自动建立并稳定一只狗的声纹模板，用于后续声纹验证。

---

## 2. 系统整体架构

系统由 **三个核心模块** 构成，职责严格解耦：

```
┌──────────────────────────┐
│ verify_embedding_process │  ← 顶层业务调度
└───────────┬──────────────┘
            │
┌───────────▼──────────────┐
│    learning_core          │  ← 自学习 / 模板管理
└───────────┬──────────────┘
            │
┌───────────▼──────────────┐
│    flash_storage          │  ← Flash/NVS 持久化
└──────────────────────────┘
```

### 2.1 模块职责划分

| 模块               | 职责                     | 是否可替换   |
| ---------------- | ---------------------- | ------- |
| verify_embedding | 事件驱动、流程编排、状态机更新        | 是       |
| learning_core    | 无监督自学习、聚类、EMA、冻结       | 否（核心算法） |
| flash_storage    | embedding / 模板 / 状态持久化 | 是       |

**重要原则**：

* learning_core **不关心事件来源**
* flash_storage **不参与算法决策**
* verify_embedding 是唯一的“调度者”

---

## 3. 数据与状态模型

### 3.1 Flash 中存储的内容

1. **embedding 原始数据**（事实）

   * 每一次 bark 事件生成一个 32 维 embedding
   * 冻结前全部落盘
   * 冻结后停止写入

2. **模板（TemplateModel）**

```c
typedef struct {
    float centroid[32];
    int   batch_count;
    bool  frozen;
} TemplateModel;
```

3. **全局状态机（flash_state）**

* total_embed_counter
* batch_embed_counter
* template_ready
* close_learning

**设计哲学**：

> Flash 保存“发生过什么”，RAM 决定“相信什么”。

---

## 4. 无监督自学习算法设计

### 4.1 设计约束

* 单犬场景（不考虑多犬竞争）
* 环境可能嘈杂（室内 / 室外）
* 必须允许学习失败
* 模板必须最终冻结

---

### 4.2 学习流程总览

**一次 batch 的学习流程：**

1. 收集 EMBED_BATCH_SIZE 个 embedding
2. batch 内一致性聚类筛选核心样本
3. 生成 batch 临时中心
4. 与全局模板做一致性校验
5. 通过 EMA 更新模板
6. 达到最大 batch 数后冻结模板

---

## 5. Batch 内一致性聚类（核心算法）

### 5.1 聚类动机

端侧无法使用复杂聚类算法（KMeans / DBSCAN），因此采用：

> **一致性最大化原则**：
> “如果这是同一只狗，那么它们之间应该彼此相似。”

---

### 5.2 算法步骤

1. **计算 batch 均值中心**
2. 计算每个 embedding 与该中心的余弦相似度
3. 按相似度排序，取 Top-K
4. 要求 Top-K 中每个相似度 ≥ EMBED_CORE_SIM_TH
5. Top-K 的均值作为 batch_centroid

若任一步失败：

* 本 batch 判定为 **学习失败**
* 模板不更新

---

## 6. 模板更新策略（EMA）

### 6.1 初始化阶段

* 第一个成功 batch：

  * 直接使用 batch_centroid 初始化模板

### 6.2 EMA 更新

```
T_new = (1 - α) * T_old + α * batch_centroid
```

其中：

* α 随 batch_count 衰减
* 初期学习快，后期稳定

### 6.3 防漂移机制

* batch_centroid 与全局模板的相似度 < TEMPLATE_UPDATE_SIM_TH
  → 拒绝更新

---

## 7. 冻结机制

### 7.1 冻结条件

* 成功 batch 数 ≥ MAX_BATCH_NUM（默认 20）

### 7.2 冻结后的行为

* 模板不再更新
* 不再存储新的 embedding
* 系统进入“验证态”

---

## 8. 为什么聚类失败的数据不删除？

这是一个**关键设计决策**：

* embedding 是真实发生的事件
* 聚类失败 ≠ 数据错误
* 删除数据会破坏时间与统计一致性

因此：

> **Flash 永远只追加，不回滚；学习模块只决定“用不用”。**

---

## 9. 顶层处理逻辑（verify_embedding）

核心流程：

1. bark 事件 → embedding 推理
2. 若未冻结 → embedding 落盘
3. batch 满 → 尝试 learning_core_try_learn
4. 根据返回结果更新状态机
5. 若模板就绪 → 进行声纹验证

---

## 10. 未来扩展设计（已预留）

### 10.1 连续失败监控

* 连续 N 次 batch 学习失败
* 判定环境变化或对象变化

### 10.2 重置机制

* 用户主动 reset
* 或策略触发 reset

### 10.3 多模板支持

* 多犬家庭
* 模板池 + 最近相似度匹配

---

## 11. 核心创新点总结（专利视角）

1. 端侧事件级无监督声纹建模
2. Batch 内一致性约束替代传统聚类
3. EMA + 冻结保证长期稳定性
4. 学习失败安全（Fail-Safe）机制

> 本系统在无人工标注、无云参与的条件下，实现了稳定、可解释、可冻结的声纹模板自学习，适用于资源受限的嵌入式设备。

---

**Author:** Kend.tank
**Date:** 2025-12-13
