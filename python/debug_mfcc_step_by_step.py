# -*- coding: utf-8 -*-
"""
逐步调试MFCC特征提取过程（Python→MCU一致性验证）
每一阶段都保存为C头文件，便于在MCU端对比。
"""

import os, re
import numpy as np
import librosa
from scipy.signal.windows import get_window
from scipy.fftpack import dct

# ============================
# 参数设置
# ============================
sr = 16000
n_fft = 400
hop = 160
n_mels = 128
n_mfcc = 40
fmin = 0.0
fmax = None

# ============================
# Step 1. 读取 test_data.h
# ============================
with open("test_data.h", "r", encoding="utf-8") as f:
    text = f.read()

nums = re.findall(r"[-+]?\d*\.\d+f?", text)
wave = np.array([float(x.replace('f', '')) for x in nums], dtype=np.float32)
print(f"波形数组读取成功: shape={wave.shape}, dtype={wave.dtype}")

# 输出目录
os.makedirs("out", exist_ok=True)

# ============================
# 通用保存函数
# ============================
def save_to_header(array, name, out_path, float_type='float'):
    array = np.asarray(array)
    flat = array.flatten()
    lines = []
    line = []
    for i, val in enumerate(flat):
        line.append(f"{val:.8f}")
        if (i + 1) % 8 == 0:
            lines.append(", ".join(line) + ",")
            line = []
    if line:
        lines.append(", ".join(line) + ",")
    with open(out_path, "w", encoding="utf-8") as f:
        f.write(f"/*\n * Auto-generated by mfcc_debug_export.py\n * Array: {name}\n */\n\n")
        f.write(f"#ifndef {name.upper()}_H\n#define {name.upper()}_H\n\n")
        f.write(f"static const {float_type} {name}[{array.size}] = {{\n")
        for l in lines:
            f.write("    " + l + "\n")
        f.write("};\n\n#endif // {name.upper()}_H\n")
    print(f"  └── 导出 {name}: shape={array.shape}, path={out_path}")

# ============================
# Step 2. Hann窗
# ============================
win_py = get_window("hann", n_fft, fftbins=True).astype(np.float32)
save_to_header(win_py, "hann_window", "out/hann_window.h")

# ============================
# Step 3. 逐帧分帧 + 加窗
# ============================
frames = librosa.util.frame(wave, frame_length=n_fft, hop_length=hop).astype(np.float32)
frames_win = frames * win_py[:, None]
save_to_header(frames_win[:, 0], "frame0_windowed", "out/frame0_windowed.h")
# 这里直接把分帧的18个帧都保存下来，便于后续对比
# for i in range(frames_win.shape[1]):
#     save_to_header(frames_win[:, i], f"frame{i}_windowed", f"out/frame{i}_windowed.h")
# 保存为二维数组 h 文件
# save_to_header(frames_win, "frame_windowed_all", "out/frame_windowed_all.h")
# 需要转置一下，变成每帧连续存储
save_to_header(frames_win.T, "frame_windowed_all", "out/frame_windowed_all.h")


# ============================
# Step 4. 功率谱
# ============================
powspec = np.abs(np.fft.rfft(frames_win, axis=0))**2   # np.fft.rfft(frames_win, axis=0) → 对每一列（每帧）做 RFFT， 因为numpy是按列优先存储的， abs(...)**2 → 得到功率谱
powspec = powspec.astype(np.float32)
# save_to_header(powspec[:, 0], "frame0_power", "out/frame0_power.h")
# 导出为一维平铺数组
powspec_all = powspec.T.flatten()  # shape = (num_frames*(FRAME_SIZE//2+1),)
save_to_header(powspec_all, "powspec_all", "out/powspec_all.h")
# # ============================
# # Step 5. Mel滤波器
# # ============================
# M_py = librosa.filters.mel(sr=sr, n_fft=n_fft, n_mels=n_mels,
#                            fmin=fmin, fmax=fmax, htk=False, norm="slaney").astype(np.float32)
# save_to_header(M_py, "mel_filterbank", "out/mel_filterbank.h")

# # ============================
# # Step 6. Mel能量谱
# # ============================
# mel_power = np.dot(M_py, powspec).astype(np.float32)
# save_to_header(mel_power[:, 0], "frame0_mel_power", "out/frame0_mel_power.h")

# # ============================
# # Step 7. Power→dB
# # ============================
# Sdb_py = librosa.power_to_db(mel_power, ref=1.0, amin=1e-10, top_db=None).astype(np.float32)
# save_to_header(Sdb_py[:, 0], "frame0_mel_db", "out/frame0_mel_db.h")

# # ============================
# # Step 8. DCT-II -> MFCC
# # ============================
# mfcc_py = dct(Sdb_py, axis=0, type=2, norm='ortho')[:n_mfcc, :].astype(np.float32)
# save_to_header(mfcc_py[:, 0], "frame0_mfcc", "out/frame0_mfcc.h")

print("\n[✓] 全部阶段导出完成！输出目录: ./out")
