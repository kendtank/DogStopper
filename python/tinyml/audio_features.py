# -*- coding: utf-8 -*-
"""
@Time    : 2025/11/12 14:16
@Author  : Kend
@FileName: audio_features
@Software: PyCharm
@modifier:
"""

import os, re
import numpy as np
import librosa
from scipy.signal.windows import get_window
from scipy.fftpack import dct
from scipy.fftpack import fft
import soundfile as sf


# ============================
# 参数设置
# ============================
sr = 16000
frame_size = 400
hop = 160
n_fft = 512
num_bins = n_fft // 2 + 1
n_mels = 64  # mel滤波器个数
n_mfcc = 13
fmin = 0.0
fmax = sr/2.0 -1

audio_files = [
    "/home/kend/Guanxin/work/ESP32_S3/MCU/speechDog-master-1111/speechDog-master/datasets/dog_braking/train/aug_3.wav",
    "/home/kend/Guanxin/work/ESP32_S3/MCU/speechDog-master-1111/speechDog-master/datasets/dog_braking/train/aug_10.wav",
    "/home/kend/Guanxin/work/ESP32_S3/MCU/speechDog-master-1111/speechDog-master/datasets/dog_braking/train/aug_20.wav"
]



def read_wave_mcu_style(wav_path):
    # 用 soundfile 直接读 int16 PCM， 前提是音频都已经预处理为 16KHz 单声道
    wave, _ = sf.read(wav_path, dtype='int16')  # 对齐pcm数据采样
    # 取前 3200 点（对应 200ms @16kHz）
    wave_window = wave[:3200]
    print(f"波形数组读取成功: shape={wave_window.shape}, dtype={wave_window.dtype}")
    return wave_window

def read_wave_mcu_style_float(wav_path):
    # 用 soundfile 直接读 int16 PCM， 前提是音频都已经预处理为 16KHz 单声道
    wave, _ = sf.read(wav_path, dtype='int16')  # 对齐pcm数据采样
    # 取前 3200 点（对应 200ms @16kHz）
    wave_window = wave[:3200]
    # 转 float32，除以 32768.f
    wave_float = wave_window.astype(np.float32) / 32768.0   # 对齐mcu行为，转换为 float32， 归一化
    print(f"波形数组读取成功: shape={wave_float.shape}, dtype={wave_float.dtype}")
    return wave_float


def save_to_header(array, name, out_path, dtype='float32'):
    """
    导出数组到 C/C++ header 文件
    array: np.ndarray
    name: 变量名
    out_path: 文件路径
    dtype: 'float32' 或 'int16'
    """
    array = np.asarray(array)
    flat = array.flatten()
    lines = []
    line = []

    for i, val in enumerate(flat):
        if dtype == 'float32':
            # 浮点类型，指数形式 + f
            line.append(f"{val:.10e}f")
        elif dtype == 'int16':
            # 整型，直接输出整数
            line.append(f"{int(val)}")
        else:
            raise ValueError("dtype must be 'float32' or 'int16'")

        if (i + 1) % 8 == 0:
            lines.append(", ".join(line) + ",")
            line = []

    if line:
        lines.append(", ".join(line) + ",")

    # 写入 header 文件
    with open(out_path, "w", encoding="utf-8") as f:
        f.write(f"/*\n * Auto-generated by save_to_header\n * Array: {name}\n */\n\n")
        f.write(f"#ifndef {name.upper()}_H\n#define {name.upper()}_H\n\n")
        c_type = 'float' if dtype == 'float32' else 'int16_t'
        f.write(f"static const {c_type} {name}[{array.size}] = {{\n")
        for l in lines:
            f.write("    " + l + "\n")
        f.write("};\n\n")
        f.write(f"#endif // {name.upper()}_H\n")

    print(f"  └── 导出 {name}: shape={array.shape}, dtype={dtype}, path={out_path}")




# 读取3组音频文件， 作为测试py端和MCU端mfcc对比
def read_audio_files():
    for wave in audio_files:
        wave_int16 = read_wave_mcu_style(wave)
        # 获取音频路径的音频名作为变量名
        name = os.path.basename(wave).split(".")[0]
        print(f"  └── 读取音频文件: {wave}")
        print(f"  └── 音频文件: {wave_int16.shape}, dtype={wave_int16.dtype}")
        # 保存为头文件，放在mcu中测试
        save_to_header(wave_int16, name, f"{name}.h", dtype='int16')

def get_dct_matrix(MEL_BANDS=64, MFCC_COEFFS=13):
    dct_matrix = np.zeros((MFCC_COEFFS, MEL_BANDS), dtype=np.float32)
    for k in range(MFCC_COEFFS):
        for n in range(MEL_BANDS):
            dct_matrix[k, n] = np.cos(np.pi * k * (n + 0.5) / MEL_BANDS)
    # 归一化
    dct_matrix[0, :] *= np.sqrt(1.0 / MEL_BANDS)
    dct_matrix[1:, :] *= np.sqrt(2.0 / MEL_BANDS)

    return dct_matrix


def libsoras_mfcc(wave):
    mfcc_librosa = librosa.feature.mfcc(
        y=wave,
        sr=16000,
        n_fft=512,
        hop_length=160,
        win_length=400,
        window='hann',
        center=False,   # 关闭自动 padding
        n_mels=64,
        fmin=0,
        fmax=8000,
        n_mfcc=13,
        norm='ortho'
    )
    return mfcc_librosa.T


def compute_mfcc(wave):
    """计算 log-mel 特征"""
    win_py = get_window("hann", frame_size, fftbins=True).astype(np.float32)
    frames = librosa.util.frame(wave, frame_length=frame_size, hop_length=hop).astype(np.float32)
    # print("分帧的数组形状", frames.shape)
    frames_win = frames * win_py[:, None]   # 矩阵乘矩阵
    # print("frames_win.shape", frames_win.shape)
    y = frames_win.astype(np.float32)
    # 功率谱 scipy.fftpack.fft → 对齐 ESP-DSP 的 dsps_fft2r_fc32
    X = fft(y, n=n_fft, axis=0)  # 默认 scipy.fftpack.fft(x) 会把整个二维数组当作 扁平数组 做 FFT（按行展开）。
    # 功率谱（对齐 MCU：只取前 N/2+1 个 bin）
    powspec = np.abs(X[:num_bins, :]) ** 2  # Power Spectrum
    # print(f"powspec shape: {powspec.shape}")
    powspec = powspec.astype(np.float32)
    M_py = librosa.filters.mel(sr=sr, n_fft=512, n_mels=64,
                               fmin=fmin, fmax=fmax, htk=False, norm="slaney").astype(np.float32)
    # print(f"Mel滤波器读取成功: shape={M_py.shape}")
    # 计算mel
    mel_power = np.dot(M_py, powspec).astype(np.float32)
    amin = 1e-8  # 最小功率值，避免 log(0)
    top_db = 100.0  # 最大动态范围
    # 计算 dB
    S_db = 10.0 * np.log10(np.maximum(mel_power.astype(np.float32), amin))
    # top_db 限制
    S_db = np.maximum(S_db, S_db.max() - top_db)
    Sdb_py = S_db.astype(np.float32)
    dct_matrix = get_dct_matrix()
    # 使用 scipy.fftpack.dct实现DCT
    mfcc_scipy = dct(Sdb_py, axis=0, type=2, norm='ortho')[:13].astype(np.float32)
    # print("shape of mfcc_scipy:", mfcc_scipy.shape)
    # print("mfcc:", mfcc_scipy)
    return mfcc_scipy.T


# 注意，需要转置，以匹配mcu端， 后续tinyml模型也需要这样的输入


if __name__ == '__main__':
    read_audio_files()

    # py端提取自己封装的mfcc函数

    # 分别计算三个测试音频的mfcc提取
    for wave in audio_files:
        # 获取音频路径的音频名作为变量名
        name = os.path.basename(wave).split(".")[0]
        # 读取为py的int16格式转float并截短为200ms 3200点
        wave_float = read_wave_mcu_style_float(wave)
        mfcc_py = compute_mfcc(wave_float)
        print(f"  └── py端mfcc: shape={mfcc_py.shape}, dtype={mfcc_py.dtype}")
        save_to_header(mfcc_py, f"mfcc_py_{name}", f"mfcc_py_{name}.h", dtype='float32')
        # 打印第一帧
        print(f"  └── py端mfcc第一帧: {mfcc_py[0]}")
        # 执行libsroa库的mfcc提取
        mfcc_librosa = libsoras_mfcc(wave_float)
        print(f"  └── librosa mfcc: shape={mfcc_librosa.shape}, dtype={mfcc_librosa.dtype}")
        print(f"  └── librosa mfcc第一帧: {mfcc_librosa[0]}")